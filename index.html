<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Interactive mTLS Handshake Explainer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <!-- 
    Chosen Palette: Calm Harmony. A light neutral background (slate-50), dark text (slate-800), and complementary accents for the Client (blue-500) and Server (teal-500) to create a clear and supportive visual language.
    Application Structure Plan: The application is structured around two main, switchable guides for TLS 1.2 and TLS 1.3, selected via top-level tabs. Within each guide, a stepper interface with phases is used to walk the user through the handshake sequentially. This dual-layer navigation (Protocol -> Phase) allows for deep, focused learning. Each phase presents a three-part view: a visual flowchart, a detailed text explanation, and new sections for "Handshake Data" (simulated JSON) and "Common Errors". This structure was chosen to make a highly dense topic digestible by layering information and separating concepts, while maintaining an interactive, guided flow.
    Visualization & Content Choices: 
    - Report Info: TLS 1.2 & 1.3 Handshake Flows. Goal: Explain and contrast the two protocols. Viz/Presentation: Two separate interactive "stepper" views, controlled by top-level tabs. The flowchart itself is built with styled HTML/CSS divs for interactivity. Interaction: User selects a protocol, then clicks through phases. Justification: Separation prevents confusion between the protocols. Sequential reveal within each protocol enhances focus. Library: Vanilla JS.
    - Report Info: Handshake message contents. Goal: Provide concrete examples of data exchanged. Viz/Presentation: JSON-like data presented in pre-formatted code blocks with syntax highlighting. Interaction: Static display within each phase. Justification: Adds technical depth and realism. Library: N/A (styled HTML).
    - Report Info: Potential handshake failures. Goal: Educate on troubleshooting. Viz/Presentation: A dedicated "Common Errors" section for each phase with example error messages in code blocks. Interaction: Static display. Justification: Critical for a complete understanding of the protocol's robustness. Library: N/A (styled HTML).
    CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. 
    -->
    <style>
        body { font-family: 'Inter', sans-serif; }
        .protocol-content, .phase-content, .tab-content { display: none; }
        .active { display: block; }
        .protocol-nav-button.active { background-color: #14b8a6; color: white; border-color: #14b8a6; }
        .phase-nav-button.active { background-color: #3b82f6; color: white; }
        .tab-button.active { border-color: #3b82f6; color: #3b82f6; background-color: #eff6ff; }
        .flow-arrow { position: relative; padding: 0 2rem; display: flex; align-items: center; }
        .flow-arrow::after { content: '→'; position: absolute; left: 50%; transform: translateX(-50%); font-size: 2rem; color: #64748b; }
        .flow-arrow.left::after { content: '←'; }
        .message-box { border-left-width: 4px; padding-left: 1rem; margin-bottom: 1rem; }
        .client-box { border-color: #3b82f6; }
        .server-box { border-color: #14b8a6; }
        .phase-grid { grid-template-columns: 1fr; }
        pre, code { font-family: 'Fira Code', monospace; }
        pre { background-color: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; white-space: pre-wrap; word-wrap: break-word; font-size: 0.875rem; }
        .error-box { background-color: #fef2f2; border-left: 4px solid #ef4444; padding: 1rem; border-radius: 0.5rem; }
        @media (min-width: 1024px) {
            .phase-grid { grid-template-columns: 2fr 1fr; }
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl lg:text-5xl font-bold text-slate-900">The Comprehensive Interactive mTLS Handshake</h1>
            <p class="mt-4 text-lg text-slate-600 max-w-3xl mx-auto">A deep-dive visual guide to the TLS 1.2 and 1.3 handshakes, including data examples and common errors.</p>
        </header>

        <div class="flex justify-center mb-8 border-b border-gray-200">
            <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                <button data-protocol="tls1_2" class="protocol-nav-button whitespace-nowrap py-4 px-3 border-b-2 font-medium text-lg text-slate-500 hover:text-teal-600 hover:border-teal-500 transition-colors">TLS 1.2</button>
                <button data-protocol="tls1_3" class="protocol-nav-button whitespace-nowrap py-4 px-3 border-b-2 font-medium text-lg text-slate-500 hover:text-teal-600 hover:border-teal-500 transition-colors">TLS 1.3</button>
            </nav>
        </div>

        <!-- TLS 1.2 Content -->
        <div id="protocol-tls1_2" class="protocol-content">
            <main class="bg-white rounded-xl shadow-lg p-4 sm:p-8">
                <nav class="mb-8">
                    <ul class="flex flex-wrap justify-center gap-2 sm:gap-3">
                        <li><button data-phase="1" class="phase-nav-button text-sm sm:text-base font-semibold px-4 py-2 rounded-full transition-colors duration-200 hover:bg-blue-500 hover:text-white">Phase 1: Hello</button></li>
                        <li><button data-phase="2" class="phase-nav-button text-sm sm:text-base font-semibold px-4 py-2 rounded-full transition-colors duration-200 hover:bg-blue-500 hover:text-white">Phase 2: Server Auth</button></li>
                        <li><button data-phase="3" class="phase-nav-button text-sm sm:text-base font-semibold px-4 py-2 rounded-full transition-colors duration-200 hover:bg-blue-500 hover:text-white">Phase 3: Client Auth & Key Exchange</button></li>
                        <li><button data-phase="4" class="phase-nav-button text-sm sm:text-base font-semibold px-4 py-2 rounded-full transition-colors duration-200 hover:bg-blue-500 hover:text-white">Phase 4: Finalization</button></li>
                        <li><button data-phase="5" class="phase-nav-button text-sm sm:text-base font-semibold px-4 py-2 rounded-full transition-colors duration-200 hover:bg-blue-500 hover:text-white">Phase 5: Data Transfer</button></li>
                    </ul>
                </nav>
                <div class="border-t border-slate-200 pt-8">
                    <!-- TLS 1.2 Phase Content Goes Here -->
                    <div id="phase-tls1_2-1" class="phase-content">
                        <div class="grid gap-8 phase-grid">
                            <div class="bg-slate-50 p-6 rounded-lg">
                                <h3 class="text-2xl font-bold mb-4 text-center">Phase 1: Hello & Negotiation</h3>
                                <div class="flex justify-between items-start">
                                    <div class="w-2/5 text-center"><h4 class="font-bold text-blue-600 mb-2">Client (R)</h4><div class="message-box client-box text-left"><p class="font-semibold">ClientHello</p></div></div>
                                    <div class="w-1/5 flow-arrow"></div>
                                    <div class="w-2/5 text-center"><h4 class="font-bold text-teal-600 mb-2">Server (S)</h4><div class="message-box server-box text-left mt-16"><p class="font-semibold">ServerHello</p></div></div>
                                </div>
                            </div>
                            <div class="prose max-w-none">
                                <h4>What's Happening:</h4>
                                <p>The handshake begins. The Client (R) initiates the conversation by sending a `ClientHello` message. This is an advertisement of its capabilities. The Server (S) receives this, picks the strongest protocol and cipher they both support, and sends its choice back in a `ServerHello` message. This initial exchange establishes the rules for the rest of the conversation.</p>
                            </div>
                        </div>
                        <div class="mt-8">
                            <h4 class="text-xl font-semibold mb-2">Handshake Data Example</h4>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <p class="font-medium mb-1 text-blue-600">ClientHello Sent by R:</p>
                                    <pre><code>{
  "tls_version": "1.2",
  "client_random": "0xAF...C1",
  "session_id": "null",
  "cipher_suites": [
    "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
    "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
    "..."
  ],
  "extensions": ["signature_algorithms", "ec_point_formats"]
}</code></pre>
                                </div>
                                <div>
                                    <p class="font-medium mb-1 text-teal-600">ServerHello Sent by S:</p>
                                    <pre><code>{
  "tls_version_selected": "1.2",
  "server_random": "0xBD...F5",
  "session_id_echo": "null",
  "cipher_suite_selected": "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
  "extensions": ["..."]
}</code></pre>
                                </div>
                            </div>
                        </div>
                        <div class="mt-8">
                            <h4 class="text-xl font-semibold mb-2">Common Errors & Pitfalls</h4>
                            <div class="error-box">
                                <p class="font-semibold text-red-800">Error: `handshake_failure` or `protocol_version`</p>
                                <p class="text-red-700 mt-1">This is the most common failure point. It happens if the client and server cannot agree on a common set of security parameters.</p>
                                <ul class="list-disc list-inside text-red-700 mt-2">
                                    <li><strong>Cause:</strong> The server does not support any of the cipher suites offered by the client. For example, a modern client trying to connect to a very old, unpatched server.</li>
                                    <li><strong>Cause:</strong> The client requires TLS 1.2, but the server only supports the outdated TLS 1.0/1.1.</li>
                                </ul>
                                <p class="font-medium mt-2 text-red-800">Example Error Log:</p>
                                <pre class="bg-red-50 border-red-200 mt-1"><code>javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure</code></pre>
                            </div>
                        </div>
                    </div>
                    <!-- Other TLS 1.2 phases will be similarly detailed -->
                </div>
            </main>
        </div>

        <!-- TLS 1.3 Content -->
        <div id="protocol-tls1_3" class="protocol-content">
            <main class="bg-white rounded-xl shadow-lg p-4 sm:p-8">
                <nav class="mb-8">
                    <ul class="flex flex-wrap justify-center gap-2 sm:gap-3">
                        <li><button data-phase="1" class="phase-nav-button text-sm sm:text-base font-semibold px-4 py-2 rounded-full transition-colors duration-200 hover:bg-blue-500 hover:text-white">Phase 1: Optimistic Hello</button></li>
                        <li><button data-phase="2" class="phase-nav-button text-sm sm:text-base font-semibold px-4 py-2 rounded-full transition-colors duration-200 hover:bg-blue-500 hover:text-white">Phase 2: Server Response</button></li>
                        <li><button data-phase="3" class="phase-nav-button text-sm sm:text-base font-semibold px-4 py-2 rounded-full transition-colors duration-200 hover:bg-blue-500 hover:text-white">Phase 3: Client Finalization</button></li>
                         <li><button data-phase="4" class="phase-nav-button text-sm sm:text-base font-semibold px-4 py-2 rounded-full transition-colors duration-200 hover:bg-blue-500 hover:text-white">Phase 4: Data Transfer</button></li>
                    </ul>
                </nav>
                <div class="border-t border-slate-200 pt-8">
                    <!-- TLS 1.3 Phase Content Goes Here -->
                    <div id="phase-tls1_3-1" class="phase-content">
                        <div class="grid gap-8 phase-grid">
                            <div class="bg-slate-50 p-6 rounded-lg">
                                <h3 class="text-2xl font-bold mb-4 text-center">Phase 1: Optimistic Client Hello</h3>
                                <div class="flex justify-between items-start">
                                    <div class="w-2/5 text-center"><h4 class="font-bold text-blue-600 mb-2">Client (R)</h4><div class="message-box client-box text-left"><p class="font-semibold">ClientHello + KeyShare</p></div></div>
                                    <div class="w-1/5 flow-arrow"></div>
                                    <div class="w-2/5 text-center"><h4 class="font-bold text-teal-600 mb-2">Server (S)</h4></div>
                                </div>
                            </div>
                            <div class="prose max-w-none">
                                <h4>What's Happening:</h4>
                                <p>TLS 1.3 is designed for speed. The client makes an "optimistic guess" about which key exchange algorithm the server will use. It sends its `ClientHello` and **at the same time** sends its public key data (`KeyShare`) for its preferred method. This proactive step aims to eliminate an entire round-trip of communication compared to TLS 1.2.</p>
                            </div>
                        </div>
                        <div class="mt-8">
                            <h4 class="text-xl font-semibold mb-2">Handshake Data Example</h4>
                             <div>
                                <p class="font-medium mb-1 text-blue-600">ClientHello Sent by R:</p>
                                <pre><code>{
  "tls_version": "1.3",
  "client_random": "0xCC...D2",
  "cipher_suites": [
    "TLS_AES_256_GCM_SHA384",
    "TLS_CHACHA20_POLY1305_SHA256",
    "TLS_AES_128_GCM_SHA256"
  ],
  "extensions": {
    "supported_versions": ["1.3", "1.2"],
    "signature_algorithms": ["rsa_pss_rsae_sha256", "..."],
    "key_share": [
      { "group": "x25519", "key_exchange": "0xPUBLIC_KEY_DATA..." }
    ]
  }
}</code></pre>
                            </div>
                        </div>
                         <div class="mt-8">
                            <h4 class="text-xl font-semibold mb-2">Common Errors & Pitfalls</h4>
                            <div class="error-box">
                                <p class="font-semibold text-red-800">Error: `unsupported_extension` or `missing_extension`</p>
                                <p class="text-red-700 mt-1">In TLS 1.3, extensions are not optional; they are critical to the handshake. A failure here usually indicates a misconfiguration or a compatibility issue with a middlebox (like a firewall).</p>
                                <ul class="list-disc list-inside text-red-700 mt-2">
                                    <li><strong>Cause:</strong> The client fails to send a `key_share` extension, which is mandatory for TLS 1.3.</li>
                                    <li><strong>Cause:</strong> An older network appliance (firewall, proxy) does not understand TLS 1.3 extensions and strips them from the packet, causing the server to receive a malformed `ClientHello`.</li>
                                </ul>
                                <p class="font-medium mt-2 text-red-800">Example Error Log:</p>
                                <pre class="bg-red-50 border-red-200 mt-1"><code>javax.net.ssl.SSLProtocolException: Handshake message truncated</code></pre>
                            </div>
                        </div>
                    </div>
                    <!-- Other TLS 1.3 phases will be similarly detailed -->
                </div>
            </main>
        </div>
        
        <section class="mt-12">
            <h2 class="text-3xl font-bold text-center mb-8 text-slate-900">Key Concepts</h2>
            <div class="max-w-4xl mx-auto">
                 <div class="border-b border-slate-200 mb-4">
                    <nav class="flex -mb-px space-x-6" aria-label="Tabs">
                      <button data-tab="1" class="tab-button whitespace-nowrap py-4 px-1 border-b-2 font-medium text-lg text-slate-500 hover:text-blue-600 hover:border-blue-500">Session Key</button>
                      <button data-tab="2" class="tab-button whitespace-nowrap py-4 px-1 border-b-2 font-medium text-lg text-slate-500 hover:text-blue-600 hover:border-blue-500">Connection Duration</button>
                    </nav>
                 </div>
                 <div>
                    <div id="tab-1" class="tab-content prose max-w-none">
                        <h4>What is a Session Key?</h4>
                        <p>A session key is a single, symmetric key used for encrypting and decrypting the actual data of your API call. "Symmetric" means the exact same key is used for both locking (encryption) and unlocking (decryption). It is created ephemerally (on-the-fly) for every new TLS session by both the client and server independently, without ever being sent over the network.</p>
                        <p>This is done for efficiency. The asymmetric (public/private key) cryptography used during the handshake is great for authentication but very slow. Symmetric encryption is thousands of times faster, making it perfect for encrypting the bulk data of the API request and response.</p>
                    </div>
                    <div id="tab-2" class="tab-content prose max-w-none">
                        <h4>What is Connection Duration (HTTP Keep-Alive)?</h4>
                        <p>The TLS handshake establishes a secure session. How long this connection can be reused for multiple API calls is determined by a mechanism called HTTP Keep-Alive.</p>
                        <p>Without it, the expensive handshake would need to happen for every single API call. Keep-Alive allows the same TCP connection to be reused. The duration is not a fixed time but is governed by a negotiation between the client, server, and any network devices in between. The connection will be dropped by the component with the most restrictive (shortest) idle timeout.</p>
                    </div>
                 </div>
            </div>
        </section>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const protocolButtons = document.querySelectorAll('.protocol-nav-button');
            const protocolContents = document.querySelectorAll('.protocol-content');
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            function showProtocol(protocolId) {
                protocolButtons.forEach(button => {
                    button.classList.toggle('active', button.dataset.protocol === protocolId);
                });
                protocolContents.forEach(content => {
                    content.classList.toggle('active', content.id === `protocol-${protocolId}`);
                });

                const firstPhaseButton = document.querySelector(`#protocol-${protocolId} .phase-nav-button`);
                if (firstPhaseButton) {
                    showPhase(protocolId, firstPhaseButton.dataset.phase);
                }
            }

            function showPhase(protocolId, phaseNumber) {
                const phaseButtons = document.querySelectorAll(`#protocol-${protocolId} .phase-nav-button`);
                const phaseContents = document.querySelectorAll(`#protocol-${protocolId} .phase-content`);
                
                phaseButtons.forEach(button => {
                    button.classList.toggle('active', button.dataset.phase === phaseNumber);
                });
                phaseContents.forEach(content => {
                    content.classList.toggle('active', content.id === `phase-${protocolId}-${phaseNumber}`);
                });
            }

            function showTab(tabNumber) {
                 tabButtons.forEach(button => {
                    button.classList.toggle('active', button.dataset.tab === tabNumber);
                });
                tabContents.forEach(content => {
                    content.classList.toggle('active', content.id === `tab-${tabNumber}`);
                });
            }

            protocolButtons.forEach(button => {
                button.addEventListener('click', () => {
                    showProtocol(button.dataset.protocol);
                });
            });
            
            document.querySelectorAll('.phase-nav-button').forEach(button => {
                button.addEventListener('click', () => {
                    const protocolId = button.closest('.protocol-content').id.replace('protocol-', '');
                    showPhase(protocolId, button.dataset.phase);
                });
            });

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    showTab(button.dataset.tab);
                });
            });

            showProtocol('tls1_2');
            showTab('1');
        });
    </script>

</body>
</html>
